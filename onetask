#!/usr/bin/env python

import json
import os
import sys
import argparse

from collections import deque
from random import shuffle

TASKS_DATABASE = os.path.expanduser('~/.OneTask.json')


class TaskError(RuntimeError):
    pass


class TaskCollection(deque):
    """Tasks collection object."""

    def __init__(self, db_path):
        self.db_path = db_path
        # load tasks
        try:
            tasks_list = json.load(open(self.db_path, 'r'))
        except (IOError, ValueError,), err:
            raise TaskError(u"Unable to load tasks from db %s: %s"
                            % (self.db_path, err,))
        super(TaskCollection, self).__init__(tasks_list)

    @classmethod
    def load(cls, db_path):
        """Configures and returns a collection instance from a db file.
        Asks the user to creates a new db file if none has been found.
        """
        if os.path.exists(db_path):
            return cls(db_path)
        print u"No OneTask database file found at %s" % db_path
        if (raw_input(u"Do you want me to create one? [Yn] ").lower()
            in ("y", "",)):
            cls.create_db(db_path)
            return cls(db_path)
        raise TaskError(u"Operation cancelled.")

    @classmethod
    def create_db(cls, db_path):
        "Creates a new JSON tasks db file."
        assert not os.path.exists(db_path)
        try:
            db_file = open(db_path, 'w')
        except IOError, err:
            raise TaskError(u"Unable to create tasks database at %s: %s"
                             % (db_path, err))
            sys.exit(1)
        db_file.write('[]')
        db_file.close()
        print u"Created tasks database at %s" % db_path

    def add(self, task):
        "Adds a new task to the collection while keeping current active one."
        if task in self:
            raise TaskError(u'Task "%s" already exists.' % task)
        if len(self) > 0:
            # pop current active task
            active = self.popleft()
            # shuffle rest
            shuffle(self)
            # add new task
            self.append(task)
            # restore active tasks
            self.appendleft(active)
        else:
            self.append(task)
        self.update_db()
        print u'Task "%s" added' % task

    def done(self):
        "Marks current active task as done."
        try:
            task = self.popleft()
        except IndexError:
            raise TaskError(u"Empty task list.")
        shuffle(self)
        self.update_db()
        print u'Task "%s" marked as done' % task

    def get(self):
        "Retrieves current active task."
        if len(self) == 0:
            raise TaskError(u"No tasks.")
        print self[0]

    def update_db(self):
        "Updates the task db with current data."
        db_file = open(self.db_path, 'w')
        db_file.write(json.dumps(list(self)))
        db_file.close()


def get_args(args_list):
    parser = argparse.ArgumentParser(
        description='OneTask let you focus on one task at the time, avoiding '
                    'discouragement by seing all the remaining work to do.')
    subparsers = parser.add_subparsers(help='available actions')
    add_subparser = subparsers.add_parser('add', help='add a new task')
    add_subparser.add_argument('task', type=str, help='task message')
    add_subparser.set_defaults(func=tasks.add)
    get_subparser = subparsers.add_parser('get',
        help='display currently active task')
    get_subparser.set_defaults(func=tasks.get)
    done_subparser = subparsers.add_parser('done',
        help='mark active task as done')
    done_subparser.set_defaults(func=tasks.done)
    if len(args_list) == 0:
        return parser.print_help()
    else:
        return parser.parse_args(args_list)

if __name__ == '__main__':
    tasks = TaskCollection.load(TASKS_DATABASE)
    args = get_args(sys.argv[1:])
    try:
        if args.func == tasks.add:
            args.func(unicode(args.task, "utf-8"))
        else:
            args.func()
    except AttributeError:
        pass
    except TaskError, err:
        sys.stderr.write(str(err) + "\n")
        sys.exit(1)

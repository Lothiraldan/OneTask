#!/usr/bin/env python

import json
import os
import sys
import argparse

from collections import deque
from random import shuffle

TASKS_DATABASE = os.path.expanduser('~/.OneTask.json')


class TaskError(RuntimeError):
    pass


class TaskCollection(deque):
    """Tasks collection object."""

    def __init__(self, db_path):
        self.db_path = db_path
        # load tasks
        try:
            tasks_list = json.load(open(self.db_path, 'r'))
        except (IOError, ValueError,), err:
            self.err(u"Unable to load tasks from db %s: %s"
                     % (self.db_path, err,), 1)
        super(TaskCollection, self).__init__(tasks_list)

    @classmethod
    def load(cls, db_path):
        """Configures and returns a collection instance from a db file.
        Asks the user to creates a new db file if none has been found.
        """
        if os.path.exists(db_path):
            return cls(db_path)
        print "No OneTask database file found at %s" % db_path
        if (raw_input(u"Do you want me to create one? [Yn] ").lower()
            in ("y", "",)):
            cls.create_db(db_path)
            return cls(db_path)
        else:
            sys.stderr.write("Exiting.\n")
            sys.exit(1)

    @classmethod
    def create_db(cls, db_path):
        "Creates a new JSON tasks db file."
        assert not os.path.exists(db_path)
        try:
            db_file = open(db_path, 'w')
        except IOError, err:
            sys.stderr.write(u"Unable to create tasks database at %s: %s"
                             % (db_path, err))
            sys.exit(1)
        db_file.write('[]')
        db_file.close()
        print "Created tasks database at %s" % db_path

    def add(self, task):
        "Adds a new task to the collection while keeping current active one."
        if task in self:
            self.err(u'Task "%s" already exists.' % task)
        if len(self) > 0:
            # pop current active task
            active = self.popleft()
            # shuffle rest
            shuffle(self)
            # add new task
            self.append(task)
            # restore active tasks
            self.appendleft(active)
        else:
            self.append(task)
        self.update_db()
        print u'Task "%s" added' % task

    def done(self):
        "Marks current active task as done."
        try:
            task = self.popleft()
        except IndexError:
            return self.err(u"Empty task list.", 1)
        shuffle(self)
        self.update_db()
        print u'Task "%s" marked as done' % task

    def err(self, message, status=1):
        "Prints out an error message to stderr and exits."
        assert status > 0
        sys.stderr.write(unicode(message) + "\n")
        sys.exit(status)

    def get(self):
        "Retrieves current active task."
        if len(self) == 0:
            self.err(u"No tasks.")
        print self[0]

    def update_db(self):
        "Updates the task db with current data."
        db_file = open(self.db_path, 'w')
        db_file.write(json.dumps(list(self)))
        db_file.close()


def get_args(args_list):
    parser = argparse.ArgumentParser(description='OneTask cli.')

    subparsers = parser.add_subparsers(help='command helps')

    add_subparser = subparsers.add_parser('add', help='add command help')
    add_subparser.add_argument('task', type=str, help='task message')
    add_subparser.set_defaults(func=tasks.add)

    get_subparser = subparsers.add_parser('get', help='get command help')
    get_subparser.set_defaults(func=tasks.get)

    done_subparser = subparsers.add_parser('done', help='done command help')
    done_subparser.set_defaults(func=tasks.done)

    return parser.parse_args(args_list)

if __name__ == '__main__':
    tasks = TaskCollection.load(TASKS_DATABASE)
    args = get_args(sys.argv[1:])

    # Commands
    if args.func == tasks.add:
        args.func(unicode(args.task, "utf-8"))
    else:
        args.func()
